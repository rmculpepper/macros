_Macros_: Useful macros and macro-writing utilities
===================================================

By Ryan Culpepper
(ryanc at plt-scheme dot org)

This package provides useful syntactic extensions (macros) as well as
procedures helpful for writing macros.

_qd.ss_: "Quick and Dirty" inspection
=====================================

Imported with:
  (require (planet "qd.ss" ("ryanc" "macros.plt" 1)))

The "qd.ss" module provides special forms useful for interactive
debugging of syntax bindings, such as those introduced by
define-struct. Please don't use this library in real code.

> syntax-local-value/quote SYNTAX
> syntax-local-value/quote-syntax SYNTAX

  These forms take an identifier bound by define-syntax or
  let-syntax, look up its value in the syntactic environment, and
  return it as a runtime expression as an s-expression or as a syntax
  object.

  Example:
    (define-struct s (a b))
    (syntax-local-value/quote s)
      => a list of the predicate, accessors, etc
    (syntax-local-value/quote-syntax s)
      => similar, but retains extra syntax object information

> phase1-eval/quote SYNTAX
> phase1-eval/quote-syntax SYNTAX

  These forms simply evaluate their expression arguments at compile
  time (and in the compile-time environment), returning the result as
  an s-expression or as a syntax object.

    (define-for-syntax the-box (box 10))
    (phase1-eval/quote (begin0 (unbox the-box) (set-box! the-box 12)))
      => 10

> expand/stop SYNTAX

  Expands the first argument (the expression) with the stop list
  given by the second argument.

    (expand/stop (when (and 1 2) (go!)) (and))
    = #'(if (and 1 2) (begin (#%app (#%top . go!))))
      ; because 'when' expands to 'if', and the 'and' stops expansion
      ; of that subexpression, but the other subexpression gets fully
      ; expanded

> expand/stop-kernel SYNTAX

  Like expand/stop, but also includes the mzscheme core syntactic
  forms. The sequence of identifiers to stop on is optional.

    (expand/stop-kernel (when (and 1 2) (go!)))
    = (expand/stop-kernel (when (and 1 2) (go!)) ())
    = #'(if (and 1 2) (begin (go!)))
      ; because expansion stops on 'if'

  See also the procedures exported by (lib "expand.ss" "macro-debugger").

